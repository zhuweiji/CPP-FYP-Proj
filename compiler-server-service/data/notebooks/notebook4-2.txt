# Building Out the Classes

For this project, you are to code out the Player and SnakeEyes classes. The main function, Die class, and parts of the other classes have been done for you.

## Die Class

A simple class that represents a die with 6 faces.

## Player Class

For this class, you will code out the following methods: \n
1. canPeek \n
2. usePeek \n
3. increaseCurrentScore \n
4. resetCurrentScore 

## SnakeEyes Class

For this class, you will code out the following methods: \n
1. getPlayerOptions \n
2. peekOne \n
3. addToPlayerScore \n
4. reduceFromFoeScore \n
5. jump \n
6. handlePlayerOption

For the methods that you are to code out, they come with comments above them that instruct what you are expected to do. Please read them carefully. \n
After you are done, you may click on 'compile' to compile and run your code against our test cases.

<EditorGroup nofiles=false, noerrors=true, nocompile=false>
<EditorFile filename=main.cpp>
#include <iostream>
#include "tester.cpp"

int main() {
    int result = Tester::testPlayer();

    std::cout << "Testing Player class...\n";
    if (result == 0) {
        std::cout << "All test cases passed!";
    } else {
        std::cout << "Test case " << result << " failed.";
    }
    std::cout << "\n\n";

    std::cout << "Testing SnakeEyes class...\n";
    result = Tester::testSnakeEyes();
    if (result == 0) {
        std::cout << "All test cases passed!";
    } else {
        std::cout << "Test case " << result << " failed.";
    }

    std::cout << "\n";

    return 0;
}
</EditorFile>

<EditorFile filename=player.cpp>
#ifndef PLAYER_CPP
#define PLAYER_CPP
#include <iostream>

class Player {
    private:
        int currentScore;
        int peeksLeft;

    public:
        Player(int initialScore, int initialPeeks) : currentScore(initialScore), peeksLeft(initialPeeks) {
        }

        int getCurrentScore() {
            return currentScore;
        }

        void setCurrentScore(int value) {
            currentScore = value;
        }

        // returns true if player has at least 1 peek left,
        // returns false otherwise
        bool canPeek() {

        }

        // decrement the player's number of peeks left
        void usePeek() {

        }

        // increase the player's current score by value, which can be negative
        // ensure the current score does not go below 0
        int increaseCurrentScore(int value) {

        }

        // set the player's current score to 0
        void resetCurrentScore() {

        }
};
#endif
</EditorFile>

<EditorFile filename=snakeeyes.cpp>
#ifndef SNAKE_EYES_CPP
#define SNAKE_EYES_CPP
#include <vector>
#include "player.cpp"
#include "die.cpp"

class SnakeEyes {
    private:
        Player* player1; 
        Player* player2; 
        Die* die1;
        Die* die2;

        /*
            1 if player 1 wins
            2 if player 2 wins
            0 if game is still ongoing
        */
        int gameState;

    public:
        static const int WINNING_SCORE = 50;
        static const int JUMP_VALUE = 30;

        SnakeEyes() : player1(new Player(0, 3)), player2(new Player(0, 3)), die1(new Die()), die2(new Die()), gameState(0) {
        }
        
        ~SnakeEyes() {
            delete player1;
            delete player2;
            delete die1;
            delete die2;
        }

        int getGameState() {
            return gameState;
        }

        // returns a list (vector) of available options for the player
        // playerId is either 1 or 2
        // rollsRevealed informs whether the dice values have been revealed to the player
        // if false, the options are "pass" and "proceed", and "peek" if available
        // otherwise, the options depend on the dice values
        //      if both are 1, then return an empty list
        //      otherwise the return list contains "add"
        //      depending on the dice values, the list may also include "reduce" or "jump"
        std::vector<std::string> getPlayerOptions(bool rollsRevealed, const int playerId) {

        }

        void setDiceValues(int value1, int value2) {
            die1->setCurrentValue(value1);
            die2->setCurrentValue(value2);
        }

        std::pair<int, int> rollDice() {
            return std::make_pair(die1->roll(), die2->roll());
        }

        // use one peek of the player and return the value of die1
        int peekOne(Player* player) {

        }

        // add the player's score by the sum of the dice values
        // returns the new score of the player
        // remember to update gameState if the player wins
        int addToPlayerScore(Player* player) {

        }

        // reduce the foe's score by the sum of the dice values
        // return the new score of the foe
        int reduceFromFoeScore(Player* foe) {

        }

        // set the player's score to JUMP_VALUE and return JUMP_VALUE
        int jump(Player* player) {

        }

        // call the appropriate method (e.g. jump) based on option
        // if the option is "peek", return the value of dice1
        // otherwise return the new score of the player whose score got updated
        // remember to utilise one of the methods already defined above!
        int handlePlayerOption(const std::string& option, const int playerId) {

        }   
};
#endif
</EditorFile>

<EditorFile filename=die.cpp>
#ifndef DIE_CPP
#define DIE_CPP
#include <random>

class Die {
    private:
        int currentValue;
        std::random_device dev;
        std::mt19937 rng;
        std::uniform_int_distribution<std::mt19937::result_type> randomAction;

    public:
        Die() : currentValue(-1), rng(std::mt19937(dev())), randomAction(std::uniform_int_distribution<std::mt19937::result_type>(1, 6)) {
        }
        
        void setCurrentValue(int value) {
            currentValue = value;
        }

        int getCurrentValue() {
            return currentValue;
        }

        int roll() {
            currentValue = randomAction(rng);
            return currentValue;
        }
};
#endif
</EditorFile>

<EditorFile filename=tester.cpp>
#ifndef TESTER_CPP
#define TESTER_CPP
#include <algorithm>
#include <memory>
#include "SnakeEyes.cpp"

class Tester {
    public:
        static int testPlayer() {
            auto player = std::make_unique<Player>(0, 3);

            player->increaseCurrentScore(10);

            // Test case 1
            // Expected: 10
            if (player->getCurrentScore() != 10) {
                return 1;
            }

            player->increaseCurrentScore(-20);

            // Test case 2
            // Expected: 0
            if (player->getCurrentScore() != 0) {
                return 2;
            }

            player->usePeek();
            player->usePeek();

            // Test case 3
            // Expected: true
            if (!player->canPeek()) {
                return 3;
            }

            player->usePeek();

            // Test case 4
            // Expected: false
            if (player->canPeek()) {
                return 4;
            }

            player->increaseCurrentScore(10);
            player->resetCurrentScore();

            // Test case 5
            // Expected: 0
            if (player->getCurrentScore() != 0) {
                return 5;
            }

            // All passed
            return 0;
        }

        static int testSnakeEyes() {
            auto gameManager = std::make_unique<SnakeEyes>();

            gameManager->setDiceValues(4, 6);
            auto options1 = gameManager->getPlayerOptions(false, 1);
            std::vector<std::string> options2 = {"peek", "pass", "proceed"};
            std::sort(options1.begin(), options1.end());
            std::sort(options2.begin(), options2.end());

            // Test case 1
            // Expected: {"add", "peek", "pass"}
            if (!compareVectors(options1, options2)) {
                return 1;
            }

            int res = gameManager->handlePlayerOption("peek", 1);

            // Test case 2
            // Expected: 4
            if (res != 4) {
                return 2;
            }

            options1 = gameManager->getPlayerOptions(true, 1);
            options2 = {"add"};
            std::sort(options1.begin(), options1.end());
            std::sort(options2.begin(), options2.end());

            // Test case 3
            // Expected: {"add"}
            if (!compareVectors(options1, options2)) {
                return 3;
            }

            res = gameManager->handlePlayerOption("add", 1);

            // Test case 4
            // Expected: 10
            if (res != 10) {
                return 4;
            }

            gameManager->setDiceValues(5, 2);
            options1 = gameManager->getPlayerOptions(true, 2);
            options2 = {"add", "jump"};
            std::sort(options1.begin(), options1.end());
            std::sort(options2.begin(), options2.end());

            // Test case 5
            // Expected: {"add", "jump"}
            if (!compareVectors(options1, options2)) {
                return 5;
            }

            res = gameManager->handlePlayerOption("jump", 2);

            // Test case 6
            // Expected: 30
            if (res != 30) {
                return 6;
            }

            gameManager->setDiceValues(3, 1);
            options1 = gameManager->getPlayerOptions(true, 1);
            options2 = {"add", "reduce"};
            std::sort(options1.begin(), options1.end());
            std::sort(options2.begin(), options2.end());
            
            // Test case 7
            // Expected: {"add", "reduce"}
            if (!compareVectors(options1, options2)) {
                return 7;
            }

            res = gameManager->handlePlayerOption("reduce", 1);

            // Test case 8
            // Expected: 26
            if (res != 26) {
                return 8;
            }

            gameManager->setDiceValues(1, 1);
            options1 = gameManager->getPlayerOptions(true, 2);
            options2 = {};
            std::sort(options1.begin(), options1.end());
            std::sort(options2.begin(), options2.end());
            
            // Test case 9
            // Expected: {}
            if (!compareVectors(options1, options2)) {
                return 9;
            }

            gameManager->setDiceValues(1, 5);
            gameManager->handlePlayerOption("peek", 1);
            gameManager->handlePlayerOption("peek", 1);
            options1 = gameManager->getPlayerOptions(false, 1);
            options2 = {"pass", "proceed"};
            std::sort(options1.begin(), options1.end());
            std::sort(options2.begin(), options2.end());
            
            // Test case 10
            // Expected: {"pass", "proceed"}
            if (!compareVectors(options1, options2)) {
                return 10;
            }

            gameManager->handlePlayerOption("jump", 1);
            gameManager->setDiceValues(6, 6);
            res = gameManager->handlePlayerOption("add", 1);

            // Test case 11
            // Expected: 42
            if (res != 42) {
                return 11;
            }

            gameManager->setDiceValues(6, 6);
            res = gameManager->handlePlayerOption("add", 1);

            // Test case 12
            // Expected: 54, 0
            if (res != 54 || gameManager->getGameState() != 1) {
                return 12;
            }

            return 0;
        }
    private:
        static bool compareVectors(std::vector<std::string>& v1, std::vector<std::string>& v2) {
            if (v1.size() != v2.size()) {
                return false;
            }

            for (size_t i = 0; i < v1.size(); i++) {
                if (v1[i] != v2[i]) {
                    return false;
                }
            }

            return true;
        }
};

#endif
</EditorFile>

</EditorGroup>

## Example Solution

<EditorGroup nofiles=false, noerrors=true, nocompile=false>
<EditorFile filename=main.cpp>
#include <iostream>
#include "tester.cpp"

int main() {
    int result = Tester::testPlayer();
    if (result == 0) {
        std::cout << "All test cases passed!";
    } else {
        std::cout << "Test case " << result << " failed.";
    }
    std::cout << "\n\n";

    result = Tester::testSnakeEyes();
    if (result == 0) {
        std::cout << "All test cases passed!";
    } else {
        std::cout << "Test case " << result << " failed.";
    }

    std::cout << "\n";

    return 0;
}


</EditorFile>

<EditorFile filename=player.cpp>
#ifndef PLAYER_CPP
#define PLAYER_CPP
#include <iostream>

class Player {
    private:
        int currentScore;
        int peeksLeft;

    public:
        Player(int initialScore, int initialPeeks) : currentScore(initialScore), peeksLeft(initialPeeks) {
        }

        int getCurrentScore() {
            return currentScore;
        }

        void setCurrentScore(int value) {
            currentScore = value;
        }

        // returns true if player has at least 1 peek left,
        // returns false otherwise
        bool canPeek() {
            return peeksLeft > 0;
        }

        // decrement the player's number of peeks left
        void usePeek() {
            --peeksLeft;
        }

        // increase the player's current score by value, which can be negative
        // ensure the current score does not go below 0
        int increaseCurrentScore(int value) {
            currentScore = std::max(0, currentScore + value);
            return currentScore;
        }

        // set the player's current score to 0
        void resetCurrentScore() {
            currentScore = 0;
        }
};
#endif
</EditorFile>

<EditorFile filename=snakeeyes.cpp>
#ifndef SNAKE_EYES_CPP
#define SNAKE_EYES_CPP
#include <vector>
#include "player.cpp"
#include "die.cpp"

class SnakeEyes {
    private:
        Player* player1; 
        Player* player2; 
        Die* die1;
        Die* die2;

        /*
            1 if player 1 wins
            2 if player 2 wins
            0 if game is still ongoing
        */
        int gameState;

    public:
        static const int WINNING_SCORE = 50;
        static const int JUMP_VALUE = 30;

        SnakeEyes() : player1(new Player(0, 3)), player2(new Player(0, 3)), die1(new Die()), die2(new Die()), gameState(0) {
        }
        
        ~SnakeEyes() {
            delete player1;
            delete player2;
            delete die1;
            delete die2;
        }

        int getGameState() {
            return gameState;
        }

        std::vector<std::string> getPlayerOptions(bool rollsRevealed, const int playerId) {
            Player* player = playerId == 1 ? player1 : player2;

            if (rollsRevealed) {
                if (die1->getCurrentValue() == 1 && die2->getCurrentValue() == 1) {
                    // Snake Eyes
                    return {};
                }

                auto options = std::vector<std::string>(1, "add");
                
                if (die1->getCurrentValue() % 2 == 1 && die2->getCurrentValue() % 2 == 1) {
                    // Both odd
                    options.push_back("reduce");
                } else if (die1->getCurrentValue() + die2->getCurrentValue() == 7) {
                    // Both add to 7
                    options.push_back("jump");
                }

                return options;
            } else {
                if (player->canPeek()) {
                    return {"peek", "pass", "proceed"};
                } else {
                    return {"pass", "proceed"};
                }
            }
        }

        int handlePlayerOption(const std::string& option, const int playerId) {
            Player* player = playerId == 1 ? player1 : player2;

            if (option == "peek") {
                return peekOne(player);
            } else if (option == "add") {
                return addToPlayerScore(player);
            } else if (option == "reduce") {
                return reduceFromFoeScore(playerId == 1 ? player2 : player1);
            } else {
                // jump option
                return jump(player);
            }
        }

        void setDiceValues(int value1, int value2) {
            die1->setCurrentValue(value1);
            die2->setCurrentValue(value2);
        }

        std::pair<int, int> rollDice() {
            return std::make_pair(die1->roll(), die2->roll());
        }

        int peekOne(Player* player) {
            player->usePeek();
            return die1->getCurrentValue();
        }

        int addToPlayerScore(Player* player) {
            int newScore = player->increaseCurrentScore(die1->getCurrentValue() + die2->getCurrentValue());

            if (newScore >= WINNING_SCORE) {
                gameState = player == player1 ? 1 : 2;
            }

            return newScore;
        }

        int reduceFromFoeScore(Player* foe) {
            return foe->increaseCurrentScore(-die1->getCurrentValue() - die2->getCurrentValue());
        }

        int jump(Player* player) {
            player->setCurrentScore(JUMP_VALUE);
            return JUMP_VALUE;
        }        
};
#endif
</EditorFile>

<EditorFile filename=die.cpp>
#ifndef DIE_CPP
#define DIE_CPP

#include <random>

class Die {
    private:
        int currentValue;
        std::random_device dev;
        std::mt19937 rng;
        std::uniform_int_distribution<std::mt19937::result_type> randomAction;

    public:
        Die() : currentValue(-1), rng(std::mt19937(dev())), randomAction(std::uniform_int_distribution<std::mt19937::result_type>(1, 6)) {
        }
        
        void setCurrentValue(int value) {
            currentValue = value;
        }

        int getCurrentValue() {
            return currentValue;
        }

        int roll() {
            currentValue = randomAction(rng);
            return currentValue;
        }
};
#endif
</EditorFile>

<EditorFile filename=tester.cpp>
#ifndef TESTER_CPP
#define TESTER_CPP

#include <algorithm>
#include <memory>
#include "SnakeEyes.cpp"


class Tester {
    public:
        static int testPlayer() {
            auto player = std::make_unique<Player>(0, 3);

            player->increaseCurrentScore(10);

            // Test case 1
            // Expected: 10
            if (player->getCurrentScore() != 10) {
                return 1;
            }

            player->increaseCurrentScore(-20);

            // Test case 2
            // Expected: 0
            if (player->getCurrentScore() != 0) {
                return 2;
            }

            player->usePeek();
            player->usePeek();

            // Test case 3
            // Expected: true
            if (!player->canPeek()) {
                return 3;
            }

            player->usePeek();

            // Test case 4
            // Expected: false
            if (player->canPeek()) {
                return 4;
            }

            player->increaseCurrentScore(10);
            player->resetCurrentScore();

            // Test case 5
            // Expected: 0
            if (player->getCurrentScore() != 0) {
                return 5;
            }

            // All passed
            return 0;
        }

        static int testSnakeEyes() {
            auto gameManager = std::make_unique<SnakeEyes>();

            gameManager->setDiceValues(4, 6);
            auto options1 = gameManager->getPlayerOptions(false, 1);
            std::vector<std::string> options2 = {"peek", "pass", "proceed"};
            std::sort(options1.begin(), options1.end());
            std::sort(options2.begin(), options2.end());

            // Test case 1
            // Expected: {"add", "peek", "pass"}
            if (!compareVectors(options1, options2)) {
                return 1;
            }

            int res = gameManager->handlePlayerOption("peek", 1);

            // Test case 2
            // Expected: 4
            if (res != 4) {
                return 2;
            }

            options1 = gameManager->getPlayerOptions(true, 1);
            options2 = {"add"};
            std::sort(options1.begin(), options1.end());
            std::sort(options2.begin(), options2.end());

            // Test case 3
            // Expected: {"add"}
            if (!compareVectors(options1, options2)) {
                return 3;
            }

            res = gameManager->handlePlayerOption("add", 1);

            // Test case 4
            // Expected: 10
            if (res != 10) {
                return 4;
            }

            gameManager->setDiceValues(5, 2);
            options1 = gameManager->getPlayerOptions(true, 2);
            options2 = {"add", "jump"};
            std::sort(options1.begin(), options1.end());
            std::sort(options2.begin(), options2.end());

            // Test case 5
            // Expected: {"add", "jump"}
            if (!compareVectors(options1, options2)) {
                return 5;
            }

            res = gameManager->handlePlayerOption("jump", 2);

            // Test case 6
            // Expected: 30
            if (res != 30) {
                return 6;
            }

            gameManager->setDiceValues(3, 1);
            options1 = gameManager->getPlayerOptions(true, 1);
            options2 = {"add", "reduce"};
            std::sort(options1.begin(), options1.end());
            std::sort(options2.begin(), options2.end());
            
            // Test case 7
            // Expected: {"add", "reduce"}
            if (!compareVectors(options1, options2)) {
                return 7;
            }

            res = gameManager->handlePlayerOption("reduce", 1);

            // Test case 8
            // Expected: 26
            if (res != 26) {
                return 8;
            }

            gameManager->setDiceValues(1, 1);
            options1 = gameManager->getPlayerOptions(true, 2);
            options2 = {};
            std::sort(options1.begin(), options1.end());
            std::sort(options2.begin(), options2.end());
            
            // Test case 9
            // Expected: {}
            if (!compareVectors(options1, options2)) {
                return 9;
            }

            gameManager->setDiceValues(1, 5);
            gameManager->handlePlayerOption("peek", 1);
            gameManager->handlePlayerOption("peek", 1);
            options1 = gameManager->getPlayerOptions(false, 1);
            options2 = {"pass", "proceed"};
            std::sort(options1.begin(), options1.end());
            std::sort(options2.begin(), options2.end());
            
            // Test case 10
            // Expected: {"pass", "proceed"}
            if (!compareVectors(options1, options2)) {
                return 10;
            }

            gameManager->handlePlayerOption("jump", 1);
            gameManager->setDiceValues(6, 6);
            res = gameManager->handlePlayerOption("add", 1);

            // Test case 11
            // Expected: 42
            if (res != 42) {
                return 11;
            }

            gameManager->setDiceValues(6, 6);
            res = gameManager->handlePlayerOption("add", 1);

            // Test case 12
            // Expected: 54, 0
            if (res != 54 || gameManager->getGameState() != 1) {
                return 12;
            }

            return 0;
        }
    private:
        static bool compareVectors(std::vector<std::string>& v1, std::vector<std::string>& v2) {
            if (v1.size() != v2.size()) {
                return false;
            }

            for (size_t i = 0; i < v1.size(); i++) {
                if (v1[i] != v2[i]) {
                    return false;
                }
            }

            return true;
        }
};

#endif
</EditorFile>


</EditorGroup>